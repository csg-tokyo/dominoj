/*
 * DominoJ is an extension to Java for supporting method slots,
 * and this project is an implementation of its compiler built on top of JastAddJ.
 * 
 * Copyright (c) 2011-, YungYu Zhuang. All rights reserved.
 *
 * The contents of this file are licensed under the modified BSD License
 * (please see the LICENSE file for the full text).
 */

/*
 * Utilities for identifying a method slot.
 */

aspect IdentifyMethod {

    /*
     * check if two method slots have the same parameters.
     */
    public boolean MethodDecl.hasSameParameters(MethodDecl m) {
        int np = getNumParameter();
        int mnp = m.getNumParameter();
        if(! (np == mnp
              || np  == mnp - m.getNumAdditionalParameter() && m.isParameterModified()
              || mnp == np - getNumAdditionalParameter()    && isParameterModified()
             ))    return false;
        if(!getTypeAccess().type().erasure().typeName().equals(m.getTypeAccess().type().erasure().typeName()))    return false;
        for(int i = 0; i < Math.min(getNumParameter(), m.getNumParameter()); i++) {
            //System.out.println(name() + " " + m.name() + " " + i + " " + getParameter(i).type().erasure().typeName() + " " + m.getParameter(i).type().erasure().typeName());
            if(!getParameter(i).type().erasure().typeName().equals(m.getParameter(i).type().erasure().typeName()))    return false;
        }
        return true;
    }

    /*
     * check if the parameter is modified by the compiler
     */
    public boolean MethodDecl.isParameterModified() {
        int np = getNumParameter();
        if((isVoid() && np < 5) || (!isVoid() && np < 6))    return false;
        TypeDecl otype = hostType().lookupType("java.lang", "Object");
        TypeDecl ctype = hostType().lookupType("dominoj", "Closure");
        ParameterDeclaration pdc, pdo, pds, pdp, pdi;
        ParameterDeclaration pdr = null;
        int idx = 0;
        if(!isVoid()) {    // has return value
            pdr = getParameter(idx++);
        }
        pdc = getParameter(idx++);
        pdo = getParameter(idx++);
        pds = getParameter(idx++);
        pdp = getParameter(idx++);
        pdi = getParameter(idx++);
        idx = 0;
        if((isVoid()
            || ((pdr.getID().equals("$retval") || pdr.getID().equals("p"+idx++)) && pdr.type().name().equals(getTypeAccess().type().name())))
           && (pdc.getID().equals("$caller")      || pdc.getID().equals("p"+idx++)) && pdc.type().name().equals(otype.name())
           && (pdo.getID().equals("$predecessor") || pdo.getID().equals("p"+idx++)) && pdo.type().name().equals(otype.name())
           && (pds.getID().equals("$self")        || pds.getID().equals("p"+idx++)) && pds.type().name().equals(otype.name())
           && (pdp.getID().equals("$proceed")     || pdp.getID().equals("p"+idx++)) && pdp.type().name().equals(ctype.name())
           && (pdi.getID().equals("$impl")        || pdi.getID().equals("p"+idx++)) && pdi.type().name().equals(ctype.name())
           ) {
                return true;
        }
        return false;
    }

    /*
     * return the number of parameters added by the compiler
     */
    public int MethodDecl.getNumAdditionalParameter() {
        if(isVoid())    return 5;    // $caller, $predecessor, $self, $proceed, $impl,
        else    return 6;            // and $retval.
    }

    /*
     * check if a method slot is generic to another method slot.
     */
    public boolean MethodDecl.hasGenericParameters(MethodDecl m) {
        if((   !isParameterModified() && getNumParameter() == 1
            ||  isParameterModified() && getNumParameter() == getNumAdditionalParameter()+1)
           && getParameter(getNumParameter()-1).type().erasure().typeName().equals("java.lang.Object[]")
           && (  !m.isVoid() && getTypeAccess().type().erasure().typeName().equals("java.lang.Object")
               || m.isVoid() && isVoid()))
            return true;
        return false;
    }
    public boolean MethodDecl.isGeneric() {
        return hasGenericParameters(this);
    }

    /*
     * mark the method declarations generated by the compiler.
     */
    public boolean MethodDecl.generated  = false;
    public void TypeDecl.addMethodDecl(MethodDecl md) {
        md.generated = true;
        addBodyDecl(md);
        //System.out.println(md.getBlock());
        //System.out.println("added " + name() + ":" + md.signature());
    }

    /*
     * return a unique id for a method declaration.
     * for overridden methods cls must be false.
     */
    public String MethodDecl.methodId(boolean constructor, boolean cls) {
        // use signature-like id instead of serial number to allow compiling classes individually
        TypeDecl td = hostType();
        //System.out.println(td);
        String id = name();
        if(cls) {
            id = td.name() + "$" + id;
            if(td.isNestedType())    id = td.enclosingType().name() + "$" + id;
        }
        //System.out.println("methodId: " + id);
        // TODO: correctly generate methodId for the <> parameters
        String sign = "";
        for(int i = 0; i < getNumParameter(); i++) {
            sign += "$" + getParameter(i).type().erasure().typeName().replace('.', '_').replaceAll("\\[\\]", "s");
        }
        String appendix = getAppendix();
        if(sign.startsWith(appendix))
            id += sign;
        else
            id += appendix + sign;
        return id;
    }
    public String MethodDecl.methodId(boolean constructor) {
        return methodId(constructor, false);
    }
    public String MethodDecl.methodId() {
        return methodId(false, false);
    }
    public String MethodDecl.getAppendix() {
        String id = "";
        if(!isVoid()) {
            id += "$" + getTypeAccess().type().erasure().typeName().replace('.', '_').replaceAll("\\[\\]", "s");
        }
        TypeDecl otype = hostType().lookupType("java.lang", "Object");
        for(int i=0; i<3; i++) {    // for $caller, $predecessor, and $self
            id += "$" + otype.erasure().typeName().replace('.', '_').replaceAll("\\[\\]", "s");
        }
        TypeDecl ctype = hostType().lookupType("dominoj", "Closure");
        for(int i=0; i<2; i++) {    // for $proceed and $impl
            id += "$" + ctype.erasure().typeName().replace('.', '_').replaceAll("\\[\\]", "s");
        }
        return id;
    }
    private HashMap<String, String> ClassDecl.methodIdMap = new HashMap<String, String>();
    private int ClassDecl.methodIdIndex = 0;
    public boolean ClassDecl.hasMethodId(String signature) {
        return methodIdMap.containsKey(signature);
    }
    public String ClassDecl.getMethodId(String signature, boolean create) {
        //System.out.println("getMethodId: " + signature);
        String mid = methodIdMap.get(signature);
        if(mid == null) {
            if(create) {
                // has overridden method
                // methodIdIndex is unique. method name is for trace
                int end = signature.indexOf("(");
                mid = name() + "$" + signature.substring(0, end) + "$" + methodIdIndex;
                methodIdMap.put(signature, mid);
                methodIdIndex++;
            } else {
                // find the id used in ancestors
                ClassDecl c = this;
                while(mid == null && c.hasSuperclass()) {
                    c = c.superclass();
                    Iterator iter = c.methodsIterator();
                    while(iter.hasNext()) {
                        MethodDecl m = (MethodDecl)iter.next();
                        String ms = m.signature();
                        String[] str = ms.split("\\$");
                        if(str.length >= 4 && str[0].equals(c.name()) && str[str.length-1].startsWith("impl")) {
                            String orig = str[1]+str[str.length-1].substring(4);
                            if(orig.equals(signature)) {
                                int en = ms.indexOf("(");
                                mid = ms.substring(0, en-5);
                            }
                        }
                    }
                }
            }
        }
        //System.out.println("getMethodId: " + mid + " for " + signature);
        return mid;
    }

    public String MethodDecl.parmSignature() {
        int idx = signature().indexOf("(")+1;
        String parm = signature().substring(0, idx);
        if(!isVoid()) {
            parm += getTypeAccess().type().erasure().typeName() + ", ";
        }
        TypeDecl otype = hostType().lookupType("java.lang", "Object");
        for(int i=0; i<3; i++) {    // for $caller, $predecessor, and $self
            parm += otype.erasure().typeName() + ", ";
        }
        TypeDecl ctype = hostType().lookupType("dominoj", "Closure");
        for(int i=0; i<2; i++) {    // for $proceed and $impl
            parm += ctype.erasure().typeName() + ", ";
        }
        if(getNumParameter() == 0)    parm = parm.substring(0, parm.lastIndexOf(",")) + ")";
        else    parm += signature().substring(idx);
        //System.out.println("parmSignature: " + parm);
        return parm;
    }

    public boolean MethodDecl.isDummy() {
        boolean ret = false;
        // check annotation
        TypeDecl type = lookupType("dominoj", "Dummy");
        if(hasAnnotation(type)) {
            ret = getAnnotation(type);
        }
        return ret;
    }
    public boolean MethodDeclSubstituted.isDummy() {
        return sourceMethodDecl().isDummy();
    }
    public boolean MethodDecl.isMethodSlot() {
        boolean ret = true;

        if(isVariableArity() || this instanceof GenericMethodDecl)    return false;
        // check annotation
        TypeDecl td = hostType();
        TypeDecl type = lookupType("dominoj", "MethodSlot");
        if(hasAnnotation(type)) {
            ret = getAnnotation(type);
            //System.out.println("hasAnnotation: " + td.name() + "." + name() + " " + ret);
            return ret;
        }
        if(!td.compilationUnit().fromSource())    return false;

        // for java.io.Serializable
        // dominoj.Closure is also forced to extends java.io.Serializable
        HashSet interfaces = td.implementedInterfaces();
        TypeDecl serial = lookupType("java.io", "Serializable");
        if(interfaces.contains(serial)) {
            //System.out.println("implementedInterfaces of " + td.name() + " contains Serializable...");
            // these methods are not declared in java.io.Serializable but need to implement
            if(   signature().equals("writeObject(java.io.ObjectOutputStream)")
               || signature().equals("readObject(java.io.ObjectInputStream)")
               || signature().equals("readObjectNoData()")
               || signature().equals("writeReplace()")
               || signature().equals("readResolve()")) {
                setAnnotation(type, false);
                //System.out.println("ignore " + td.name() + ":" + signature());
                return false;
            }
        }

        // check overridden methods
        String real = signature();
        Iterator iter = td.ancestorMethods(real).iterator();
        //System.out.println(td.ancestorMethods(real).size());
        while(iter.hasNext()) {
            MethodDecl md = (MethodDecl)iter.next();
            if(!isStatic() && !md.isPrivate() && md.accessibleFrom(td) && td.instanceOf(md.hostType())) {
                ret = md.isMethodSlot() || md.isDummy();
                //System.out.println("overrides: " + td.name() + "." + name() + " " + ret);
                return ret;
            }
        }
        
        //System.out.println("isMethodSlot: " + td.name() + "." + name() + " " + ret);
        return ret;
    }

    refine Annotations public void Annotation.checkOverride() {
        if(decl().fullName().equals("java.lang.Override") && enclosingBodyDecl() instanceof MethodDecl) {
            MethodDecl m = (MethodDecl)enclosingBodyDecl();
            if(m.isMethodSlot() && m.isParameterModified())    return;
        }
        refined();
    }

}
